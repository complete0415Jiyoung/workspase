[접근제한자]        [예약어]		[반환형]		 메소드명 	([매개변수])
public 		static		기본자료형
protect		final 		참조형(배열, 클래스)
(default)		abstract		void
private 		static final


* 필드(fied) : 객체의 속성을 작성하는 클래스 내부의 영역
		(==)멤버변수 /인스턴스변수 /클래스변수(==static변수)

*static예약어 : 공유메모리 영역 또는 정적 메모리 영역이라고함 
	프로그램 시작시 static이 붙은 모든 코드는 모두 static영역에 생성되고 프로그램이 종료되기 전까지 사라지지 않는다 
	클래스의 모든 객체들은 static의 주소를 모두 참조하고 있음  

*생성자 : new연산자를 통해 객체를 생성할때 생성된 객체의 필드값을 초기화하고 기능을 수행하는 역할
	기본 생성자/ 매개변수생성자 
	생성자 명명 규칙 - 클래스 이름과 생성자이름이 동일 / 반환형이 없다 
	매개변수 생성자 : 객체가 생성 될때 부터 다른 값을 초기화 

*this참조형 : 객체가 자신을 참조할 수 있도록 하는 변수로 모든 객체 내무에 숨겨져 있음.

*오버로딩 : 클래스에서 동일한이름의 메소드(생성자를 포함)를 여러개 작성하는 기법. 
	[오버로딩 조건]
	- 메소드 (생성자) 이름과 동일
	- 매개변수 개수, 순서, 탑입 중 한가지라도 달라야함 

* 모든 메소드는 종료시 호출되어 있는 곳으로 돌아가고 이것을 return 반환이라고 한다.
 이때 모든 메소드는 return 구문을 생성하여야 반환이 가능하다 단 void의 경우 컴파일러가 자동으로 생성해 주기 때문에 생략이 가능하다 
 void는 반환 값이 없을 때 사용하는 반환형이다. 반환값과 반환형이 같은 자료형일때 호출 부로 돌아갈수 있다.


* String Name 의 getter/setter
public String getName (){
return Name;
}
Public void setName(String name){
this.name= name;
}

* 객체지향언어의 정의 : 현실세계는 각각의 객체로 이루어져있고 발생하는 사건은 모든 객체의 상호작용으로 이루어진다. 
	이것을 컴퓨터로 옮겨 놓은 것을 객체지향언어라고 한다 

* 캡슐화 : 데이터를 하나의 묶어 보호하는 기법으로 데이터를 접근제한자 private을 사용하여 직접접근으로 부터 보호한다.
	getter/ setter을 사용하여 간접접근할 수 있다 

* 추상화 : 공통적인 속성과 기능을 추출하고 불필요한 부분을 제거하는 것 
 
 
---------------------------------------상속---------------------------------------------

<상속> 
 *상속 : 다른 클래스의 멤버(필드,메소드)들을 새로운 클래스에 새로 만들지 않고
	 상속 받음으로써 새클래스가 자신의 멤버처럼 사용할 수 있는 기능 

	- 상속의 목적 : 클래스의 재사용, 연관된 일련의 클래스에 대한 공통적인 규약 정의 
	- 상속의 장점 
		1) 보다 작은 양의 코드로 새로운 클래스 작성 가능
		2) 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이 
		3) 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여
	-방법 : extends 키워드 사용

*단일 상속과 다중 상속 
	-단일 상속 :크래스간의 다중 상속보다 명확하고 신뢰성 있는 코드 작성 
		자바에서는 다중 상속 미지원

*상속의 특징 
	1)모든 클래스는 Object클래스의 후손
		: Object 클래스가 제공하는 메소드를 오버라이딩 하여 메소드 제구현 가능 
		ex) equals(), toString():하나의 문자열로 반환하는용도의 메소드 
	2) 부모 클래스의 생성자, 초기화 블록은 상속 안됨 
 		super()활용
	3) 부모의 private멤버는 상속은 되지만 직접접근이 불가능하다  
		super() 또는 getter/setter 사용

*super() : 부모 객체의 생성자를 호출하는 메소드
		기본적으로 후손 생성자에 부모생성자를 포함 
		후손 객체 생성시에는 부모로 부터 생성이 되기 때문에 후손 클래스 생성자 안에는
		부모 생성자를 호출하는 super()가 첫줄에 존재 
		(부모 생성자가 가장 먼저 실행 되어야하기 때문 반드시 첫줄에 작성 )
		매개 변수 있는 부모 생성자 호출은 super(매개변수, 매개변수)를 넣으면 됨

*super. : 상속을 통한 자식 클래스 정의 시 해당 클래스의 부모 객체를 가르키는 참조 변수 
		자식 클래스 내에서 부모 클래스 객체에 접근하여 필드나 메소드 호출 시 사용 

*오버라이딩 (Overriding)
	:자식클래스가 상속 받은 부모의 메소드를 재정의하는 것 
	 부모가 제공하는 기능을 후손이 일부고쳐 사용하겠다는 의미로
	  자식 객체를 통한 실행시 후손 것이 우선권을 가짐 

 	[오버라이딩 성립 조건]
	1) 메소드 이름이 동일 
	2) 반환형 동일
	3) 매개변수 동일
	4) 접근제한자가 같거나 더 넓은 범위
	5) 예외 처리 범위는 같거나 더 좁게 
	6) private메소드 오버라이딩 불가
	@Override 어노테이션 : 해당 메소드가 오버라이딩 되었음을 컴파일러에게 알려주는 역할 


>>>>>>>>>>>>>>>>>오버 라이딩과 오버로딩<<<<<<<<<<<<<<<<<<<<<<<<

[오버라이딩] 
- 하위 클래스에서 매소드 정의
- 메소드 이름 동일 / 매개변수 동일(개수, 순서, 타입)/ 리턴 타입 동일 
- 자식 메소드의 접근 범위가 부모 메소드의 접근 범위 보다 더 넓거나 같아야함 
- 자식 메소드의 예외 수가 부모 메소드의 예외의 수보다 적거나 범위가 좁아야함 

[오버로딩}
- 같은 클래스에서 메소드 정의 
- 메소드 이름 동일 / 매개변수 다름(개수, 타입, 순서) /리턴 타입 상관없음 
- 접근제어자 상관없음 
- 예외 처리자 상관 없음 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

* final 예약어 
 	final클래스 : 상속이 불가능한 클래스 
	final메소드 : 상속시 오버라이딩이 불가능한 메소드 




============================================다향성================================================
* 다향성 :상속을 이용한 기술로 부모 클래스 타입 참조변수 하나로 
	상속관계에 있는 여러 타입의 자식 객체를  참조하는 기술
*업케스팅 : 부모타입의 참조 변수가 모든 자식 타입 객체의 주소를 참조할 수 있음

