public class Student { //클래스 선언부
//[접근제한자] [예약어] class 클래스명

*	[접근제한자] 	[예약어]	 	자료형			변수명[=초기값];

	 + public 	final		기본자료형
	 # protected	static		배열
	 ~ (default)	final static	클래스
	 - private		static final	(참조형)


//Student을 참조하는 참조변수 std을 생성하고 heap영역에 Student 객체를 생성한다
----------------------------------객체 속성-------------------------------------------
1. 필드(field) : 객체의 속성을 작성하는 클래스 내부 영역
	(==멤버 변수) : 메서드 밖에 작성된 변수 
  
    	- 인스턴스 변수: 필드에 작성 되는 일반 변수 
    	- 클래스 변수 ( == static변수) : 필드에 static예약어가 작성된 변수 
		같은 클래스로 만들어진 객체가 값을 공유 할 수 없기 때문에 
 	
	- 필드에서의 접근제한자는 접근이 가능한 범위를 나타낸다.
	
	//필드 
	public int v1 =10;					->인스턴스 변수     
	protected int v2 = 20;
	int v3 =30;
	private int v4 =40;		
	public static String schoolName = "KH고등학교"; 	-> 클래스 변수(==static변수)


  * 클래스 별 객체 (new)선언 시 접근제한자 
	- public 경우 import 사용하여 객체 생성이 가능  
	- (default)클래스에 있는 객체는 다른 패키지에 있어 import 통해서 가져 올 수 없다 


  * 인스턴스 변수 선언 한 접근 제한자 
	public - 전체 접근 가능 
	protected - 상속 관계에서 직접접근 가능 (extends 상속하는 클래스명)
	private - 캡슐화 원칙에 따라 사용 됨 getter setter로 간접접근 가능 
	(default) - 같은 패키지 안에서만 가능


  * static 예약어 : 공유메모리 영역(또는 정적 메모리 영역)이라고 함
 	- 프로그램이 시작할시 static이 붙은 코드들은 모두 
	  static 영역에 생성되고 프로그램이 종료 되기 전까지 사라지지 않는다
	  그리고 static영역에 생성된 변수는 어기서든지 공유할 수 있다(공유)

	- static이 붙은 필드(변수)는 클래스명.변수명을 사용함 아닐 경우 노란줄
		ex) Student. schoolName 
 


-------------------------------객체 기능(생성자 + 메소드)---------------------------------
2. 생성자 (constructor) 
	: new 연산자를 통해 객체가 생성 될때 생성된 객체의 필드 값 초기화 + 기능을 수행하는 역할  
	- 생성자의 종류 : 기본 생성자, 매개 생성자 
	- 생성자 명명의 규칙
		1) 클래스 이름과 생성자 이름이 같아야 한다 
		2) 반환형이 없다

  * 기본생성자 
	ex) public User(){ 수행 기능 + 필드 초기화 }

	문제점 : 두개 이상의 객체를 생성했을 때 참조하고 있는 User 객체의 필드값이 동일하게 나올 수 있음 
		why? 같은 기본 생성자 User 객체를 생성했기 때문 
 
	해결 방법 1: setter을 이용해서 새로운 값을 대입 
		
		ex) 실행 클래스에서
		u2.setUserId("asd123");
		
	해결 방법 2: 매개 변수 생성자를 이용해서 객체가 생성될 때 부터 다른 값을 초기화 


  * 매개 변수 생성자 : 매개변수 순서가 매우 중요 

	ex) 
	
	1) 객체를 생성한 실행 클래스
	    User u3 = new User (매개변수); 

	2) 객체 클래스 : 전달 받은 값으로 필드에 초기화 
	    public User(매개 변수){수행기능 / 필드초기화(this참조변수) }


  * this 참조 변수 : 객체가 자신을 참조 할 수 있도록 하는 변수이고, 모든 객체 내부에 숨겨져 있다. 
	why? 필드명과 매개변수를 구분하기 위해서  주로 사용 됨 
	
	ex)
	this . userId = userId;
	//       필드 = 매개변수 


  * this() 생성자 : 같은 클래스의 다른 생성자를 호출할 때 생성하고 생성자 내에서 반드시 첫번째 줄이 작성 되어야함 
	why? 중복코드 제거, 코드길이 감소, 재사용성 증가 (가독성이 어려운 경우가 생길 수 있어 많이 사용하지 않음)


  * 오버로딩(Over Loading) : 클래스 내에 동일한 이름의 메소드(생성자 포함)를 여러개 작성하는 기법
			--> 하나의 이름으로 여러 기능 수행할 수 있게하는 것

 	[오버로딩의 조건]	1.  메소드 (생성자 포함)의 이름이 동일 
			2. 매개변수의 개수, 순서, 타입 중 2개라도 달라야함 
			  ( 변수명은 신경 쓰지 않음)  

  * 반환형  : 반환 값의 자료형 
	반환 (return) : 메소드 수행 후 호출부로 돌아가는 것 
	void : 입력할 값이 없다 
	String : String 자료형 값을 가지고 돌아간다 

